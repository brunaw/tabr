#' Create a musical phrase
#'
#' Create a musical phrase from character strings that define notes, note metadata, and optionally explicit strings fretted. The latter can be used to ensure proper tablature layout.
#' Notes separated in time are separated in the \code{notes} string by spaces. Sharps and flats are indicated by appending \code{#} and \code{_}, respectively, e.g. \code{f#} or \code{g_}.
#'
#' Specifying notes that are one or multiple octaves below or above the middle can be done by appending one or multiple commas or single quote tick marks, respectively, e.g. \code{c,} or \code{c''}.
#' But this is not necessary. Instead, you can use octave numbering. This may easier to read, generally more familiar, potentially requires less typing, can still be omitted completely
#' for the middle octave (no need to type c3, d3, ...), and is automatically converted for you by \code{phrase} to the tick mark format interpreted by LilyPond.
#' That said, using the raised and lowered tick mark approach can be surprisingly easier to read for chords, which have no spaces between notes, especially six-string chords,
#' given that the tick marks help break up the notes in the chord visually much more so than integers do. See examples.
#'
#' The function \code{p} is a convenient shorthand wrapper for \code{phrase}. It also calls the \code{alt} function when the \code{alt} argument is supplied. See examples.
#'
#' Tied notes indicated by \code{~} are part of the \code{note} notation and not part of the \code{info} notation, e.g. \code{c''~}.
#'
#' Notes can comprise chords. These are bound tightly rather than space-delimited, as they are not separated in time.
#' For example, a C chord could be given as \code{ceg} and in the case of tied notes would be \code{c~e~g~}.
#'
#' Other information about a note is indicated with the \code{info} string.
#' The most pertinent information, minimally required, is the note duration. A string of space-delimited \code{notes} will always be accompanied by a space-delimited string of an equal number of integer durations.
#' Durations are powers of 2: 1, 2, 4, 8, 16, 32, 64. They represent the fraction of a measure, e.g., 2 means 1/2 of a measure and 8 refers to an eighth note.
#' Dotted notes are indicated by adding \code{.} immediately after the integer, e.g., \code{2.} or \code{2..}.
#' Any other note metadata is appended to these durations. See examples.
#'
#' Opening and closing slurs (or hammer ons and pull offs) are indicated with opening and closing parentheses, slides with \code{-}, and simple bends with \code{^}.
#' Text annotations aligned vertically with a note in time on the staff is done by appending the text to the note info entry itself. See \code{\link{notate}}.
#' For more details and example, see the package vignettes.
#'
#' In cases where a phrase is very long and is used multiple times, but there is at least one instance where that phrase might have a very slight alternate ending, the \code{alt} wrapper function can be helpful in code reduction.
#' It takes three space-delimited character string entries analogous to \code{notes}, \code{info} and \code{string}. Each of n space-delimited entries will substitute for the final n entries in the original strings.
#' The three do not have to be the same length. If only substituting the final two notes in \code{notes} for example, then the \code{alt} argument in the \code{alt} function should be something like \code{alt = c("a2 b2", "", "")}.
#' \code{alt} returns a character vector of both phrase strings, the original and the alternate, or a list of both phrase objects if \code{char = FALSE}.
#' If an entry is longer than the original, it will substitute entirely. Since it is based on space-delimitation, take care with complex \code{info} strings that might have attached text from \code{notate}.
#'
#' @param notes character, notes \code{a} through \code{g}. See details.
#' @param info character, metadata pertaining to the \code{notes }. See details.
#' @param string character, optional string that specifies which guitar strings to play for each specific note.
#' @param bar logical, insert a bar check at the end of the phrase.
#' @param abb logical, abbreviate the default LilyPond Dutch notation for A flat and E flat to \code{as} and \code{es}; recommended.
#' @param alt length 3 character vector, alternate ending substitutions for \code{notes}, \code{info} and \code{string}, respectively. See details.
#' @param times length 2 numeric vector, the number of times the original and alternate phrase should be repeated in the output when using \code{alt}, defaults to 1 each.
#' @param char logical, return character vector or list for \code{alt} function.
#' @param ... arguments passed to \code{phrase} (or to \code{alt} function).
#'
#' @return a phrase. For \code{alt}, return a length 2 character vector or list of phrases.
#' @name phrase
#' @export
#'
#' @examples
#' phrase("c ec'g' ec'g'", "4 4 2") # no explicit string specification (not recommended)
#' phrase("c ec4g4 ec4g4", "4 4 2") # same as above
#' phrase("c b, c", "4. 8( 8)", "5 5 5") # direction implies hammer on
#' phrase("b2 c d", "4( 4)- 2", "5 5 5") # hammer and slide
#'
#' phrase("c ec'g' ec'g'", "1 1 1", "5 432 432")
#' p("c ec'g' ec'g'", "1 1 1", "5 432 432") # same as above
#'
#' e <- c("c'", "2", "5")
#' alt("c ec'g' ec'g'", "1 1 1", "5 432 432", e)
#' p("c ec'g' ec'g'", "1 1 1", "5 432 432", alt = e) # same as above
#' p("c ec'g' ec'g'", "1 1 1", "5 432 432", alt = e, char = FALSE)
NULL

# nolint start

#' @export
#' @rdname phrase
phrase <- function(notes, info, string = NULL, bar = FALSE, abb = TRUE){
  .check_phrase_input(notes, "notes")
  .check_phrase_input(info, "info")
  if(!is.null(string)) .check_phrase_input(string, "string")
  notes <- (strsplit(notes, " ")[[1]] %>% purrr::map_chr(.star_expand) %>%
    paste0(collapse = " ") %>% strsplit(" "))[[1]]
  notes <- .octavesub(notes)
  info <- (strsplit(as.character(info), " ")[[1]] %>% purrr::map_chr(.star_expand) %>%
             paste0(collapse = " ") %>% strsplit(" "))[[1]]
  notes <- purrr::map_chr(notes, .tabsub)
  info <- purrr::map_chr(info, .tabsub)
  bend <- which(purrr::map_int(info, ~length(grep("\\^", strsplit(.x, ";")[[1]][1]))) == 1)
  dead <- which(purrr::map_int(info, ~length(grep("xDEADNOTEx", strsplit(.x, ";")[[1]][1]))) == 1)
  if(length(bend)) info[bend] <- gsub(";\\^", ";", info[bend])
  if(length(dead)) info[dead] <- gsub("xDEADNOTEx", "", info[dead])
  info <- gsub(";", "", info)
  .bend <- "\\bendAfter #+6"
  s <- !is.null(string)
  if(s && is.numeric(string)) string <- paste0(rep(string, length(notes)), collapse = " ")
  if(s) string <- .strsub(string)
  notes <- purrr::map_chr(
    seq_along(notes),
    ~paste0("<", paste0(.split_chord(notes[.x], abb = abb),
                        if(s && notes[.x] != "r" && notes[.x] != "s")
                          paste0("\\", .split_chord(string[.x], TRUE)), collapse = " "), ">"))
  notes <- gsub("<s>", "s", gsub("<r>", "r", notes))
  x <- paste0(notes, info)
  if(length(bend)) x[bend] <- paste0(x[bend], .bend)
  if(length(dead)) x[dead] <- paste("\\deadNote", x[dead])
  x <- gsub("\\\\x", "", x)
  x <- paste(x, collapse = " ")
  if(bar) x <- paste(x, "|")
  x <- gsub("\\| \\|", "\\|", x)
  class(x) <- c("phrase", class(x))
  x
}

# nolint end

.check_phrase_input <- function(x, y){
  if(length(x) > 1) stop(paste0("`", y, "` must be length one."))
}

#' @export
#' @rdname phrase
p <- function(...){
  if(!is.null(list(...)$alt)) alt(...) else phrase(...)
}

#' @export
print.phrase <- function(x, ...) cat(x, "\n", sep = "")

#' @export
#' @rdname phrase
alt <- function(notes, info, string = NULL, alt = NULL, times = 1, char = TRUE, bar = FALSE, abb = TRUE){
  if(is.null(alt) || identical(alt, c("", "", "")))
    return(phrase(notes, info, string, bar, abb))
  if(!is.character(alt) || length(alt) != 3) stop("`alt` must be a length 3 character vector.")

  f <- function(x, y){
    if(is.null(x)) return(y)
    if(y != ""){
      y <- strsplit(y, " ")[[1]]
      n <- length(y)
      x <- strsplit(x, " ")[[1]]
      if(n >= length(x)){
        x <- paste0(y, collapse = " ")
      } else {
        x <- paste0(c(x[1:(length(x) - n)], y), collapse = " ")
      }
    }
    x
  }

  x <- list(notes, info, string)
  y <- list(f(notes, alt[1]), f(info, alt[2]), f(string, alt[3]))
  x <- purrr::map(list(x, y), ~phrase(.x[[1]], .x[[2]], .x[[3]], bar, abb))
  times <- rep(times, length = 2)
  x <- x[c(rep(1, times[1]), rep(2, times[2]))]
  if(char) x <- as.character(x)
  x
}

#' Create a volta/repeat phrase
#'
#' Create a repeat section in LilyPond readable format.
#'
#' This function takes a musical phrase or even a basic string and converts it into a volta phrase for the LilyPond volta engraver.
#'
#' Note that basic strings should still be interpretable as a valid musical phrase by LilyPond.
#' For example, a one-measure rest, \code{"r1"} does not need to be wrapped in a phrase class to work, nor would any other string explicitly written out in valid LilyPond syntax.
#' As always, see the LilyPond documentation if you are not familiar with LilyPond syntax.
#'
#' @param phrase a phrase or basic string to be repeated.
#' @param n integer, number of repeats of \code{phrase} (one less than the total number of plays).
#' @param endings list of phrases or basic strings, alternate endings.
#' @param silent if \code{TRUE}, no text will be printed above the staff to indicate the number of plays when greater than one repeat and \code{endings} is not \code{NULL}. This is useful when another staff already displays the text.
#'
#' @return a phrase.
#' @export
#'
#' @examples
#' x <- phrase("c ec'g' ec'g'", "4 4 2", "5 432 432")
#' e1 <- phrase("a", 1, 5)
#' e2 <- phrase("b", 1, 5)
#' volta(x) # one repeat or two plays
#' pct(x) # as above, simple percent repeat notation
#' volta(x, 1, list(e1, e2)) # one repeat with alternate ending
#' volta(x, 4, list(e1, e2)) # multiple repeats but with only one alternate ending
volta <- function(phrase, n = 1, endings = NULL, silent = FALSE){
  if(n > 1 & is.null(endings) & !silent){
    phrase <- strsplit(phrase, " ")[[1]]
    idx <- grep(">", phrase)
    if(length(idx)){
      idx <- min(idx)
      phrase[idx] <- paste0(phrase[idx], paste("^\"Play", n + 1, "times.\""))
    }
    phrase <- paste0(phrase, collapse = " ")
  }
  x <- paste("\\repeat volta", n + 1, "{", paste(phrase, collapse = " "), "| }\n")
  if(!is.null(endings)){
    x <- paste0(x, "\\alternative {\n", paste("  {", endings, "| }\n", collapse = ""), "}")
  }
  x <- gsub("\\| \\|", "\\|", x)
  class(x) <- c("phrase", class(x))
  x
}

#' @export
#' @rdname volta
pct <- function(phrase, n = 1){
  x <- paste("\\repeat percent", n + 1, "{", paste(phrase, collapse = " "), " }\n")
  class(x) <- c("phrase", class(x))
  x
}
