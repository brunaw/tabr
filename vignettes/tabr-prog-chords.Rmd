---
title: "Chord functions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Chord functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
options(crayon.enabled = TRUE)
sgr_wrap <- function(x, options){
  paste0("<pre class=\"r-output\"><code>", fansi::sgr_to_html(x = htmltools::htmlEscape(x)), "</code></pre>")
}
knitr::knit_hooks$set(output = sgr_wrap)
knitr::opts_chunk$set(
  collapse = TRUE, comment = "#>", message = FALSE, warning = FALSE, error = FALSE, tidy = FALSE, out.width = "100%"
)
library(tabr)
```

## Chord identity and comparison

You have already seen `is_chord`, which is similar to `is_note`. Another check that can be performed on chords is whether they are diatonic to a scale. `chord_is_diatonic` strictly accepts chords in noteworthy strings.

```{r chords1}
x <- "ce_g cd#g"
chord_is_diatonic(x, key = "b_")
```

A few functions that compare chords are `chord_rank`, `chord_order` and `chord_sort`. Ranking chords, and the ordering and sorting based on that, requires a definition or set of definitions to work from.

The first argument is a noteworthy string. The second, `pitch`, can be `"min"` (the default), `"mean"`, or `"max"`. Each of these refers to the functions that operate on the three available definitions of ranking chords.
When ranking individual notes, the result is fixed because there are only two pitches being compared. For chords, however, `pitch = "min"` compares only the lowest pitch or root note of a chord. For `pitch = "max"`, the highest pitch note in each chord is used for establishing rank. For `pitch = "mean"`, the average of all notes in the chord are used for ranking chords.

Rank is from lowest to highest pitch. These options define how chords are ranked, but each function below also passes on additional arguments via `...` to the base functions `rank` and `order` for the additional control over the more general aspects of how ranking and ordering are done in R. `chord_order` works analogously to `chord_rank`. `chord_sort` wraps around `chord_order`.

```{r chords 2}
x <- "a2 c a2 ceg ce_g cea"
chord_rank(x, "min")
chord_rank(x, "max")
chord_rank(x, "mean")

chord_order(x)
chord_order(x, "mean")

chord_sort(x, "mean")
```

## Chord transformations

A broken chord can be created with `chord_break`, which separates a chord into its component notes, separating in time. It accepts a single chord.

```{r chords3}
x <- "ce_g"
chord_break(x)
```

`chord_invert` creates chord inversions. It also takes a single chord as input. It treats any chord as being in root position as provided.

```{r chords4}
chord_invert(x, 1)
chord_invert(x, 2)
chord_invert(x, 3)

chord_invert(x, -1)
chord_invert(x, -2)
chord_invert(x, -3)
```

While a chord with `n` notes has `n - 1` inversions, `chord_invert` allows inversions to continue, moving a chord further up or down in octaves. If you want to restrict the function to only allowing the defined number of inversions (excluding root position), set `limit = TRUE`. This enforces the rule that, for example, a chord with three notes has two inversions and `n` can only take values between `-2` and `2` or it will throw and error.

Building up on `chord_invert`, `chord_arpeggiate` grows a chord up or down the scale in pitch by creating an arpeggio. `n` describes how many steps to add onto the original chord. Setting `by = "chord"` will replicate the entire chord as is, up or down the scale. In this case `n` indicates whole octave transposition steps. By default, `n` refers to the number of steps that individual chord notes are arpeggiated, like in `chord_invert`. This means for example that in a chord with three notes, setting `n = 3` and `by = "note"` is equivalent to setting `n = 1` and `by = "chord"`.

The argument `broken = TRUE` will also convert to a broken chord, resulting in an arpeggio of individual notes.

```{r chords5}
chord_arpeggiate("ce_gb_", 2)
chord_arpeggiate("ce_gb_", -2)
chord_arpeggiate("ce_gb_", 2, by = "chord")
chord_arpeggiate("ce_gb_", 1, broken = TRUE, collapse = TRUE)
```

## Chord construction

Before introducing the chord constructors, here is a brief mention and example of the `dyad` function for constructing dyads from a root note and and interval. Dyads are not technically chords, but this is as good a place as any to mention `dyad`. The interval can be in semitones, or a named interval from `mainIntervals` that corresponds to the number of semitones.

```{r chords6}
dyad("a", 3)
x <- c("minor third", "m3", "augmented second", "A2")
sapply(x, function(x) dyad("a", x))
sapply(x, function(x) dyad("c'", x, reverse = TRUE))
```

### Available constructors

Now to the topic of chord construction. Chords are often constructed directly, but many can also be constructed using helper functions. Currently, helpers exist for common chords up through thirteenths. There are not currently any constructors for guitar-specific chord shapes and fingerings. `tabr` offers two options for each chord constructor, the longer `chord_*`-named function and its `x*` alias. The table below shows all available constructors.

```{r chords7, echo=FALSE}
name <- c("chord_min", "chord_maj", "chord_min7", "chord_dom7", "chord_7s5", "chord_maj7", "chord_min6", "chord_maj6", "chord_dim", 
  "chord_dim7", "chord_m7b5", "chord_aug", "chord_5", "chord_sus2", "chord_sus4", "chord_dom9", "chord_7s9", "chord_maj9", 
  "chord_add9", "chord_min9", "chord_madd9", "chord_min11", "chord_7s11", "chord_maj7s11", "chord_11", "chord_maj11", "chord_13", "chord_min13", "chord_maj13")
abb <- c("xm", "xM", "xm7", "x7", "x7s5", "xM7", "xm6", "xM6", "xdim", "xdim7", "xm7b5", "xaug", 
  "x5", "xs2", "xs4", "x9", "x7s9", "xM9", "xadd9", "xm9", "xma9", "xm11", "x7s11", "xM7s11", "x_11", "xM11", "x_13", "xm13", "xM13")
data.frame(full_name = name, abbreviation = abb)
```

These functions take root notes and a key signature as input. The given function determines the intervals of the chord. This in combination with a root note is all that is needed to create the chord. However, the key signature can enforce whether the result uses flats or sharps when accidentals are present.

```{r chords8}
chord_min7("a c e")
chord_min7("a c e", key = "f")
xm7("a c e", key = "f")
```

### Eventual direction

Chord constructors are a new concept and this collection of convenient wrapper functions may change significantly in a future version of `tabr`. In the context of creating guitar tablature, these are not very useful. Another concept of chord constructors will be developed in a future version with a focus on generating chords for guitar tablature. Such a constructor or set of constructors may consider information such as:

* chord shape
* number of, or which strings are used
* fret number, or minimum fret
* chord root
* separate bass note
* bar or open

Some of these considerations could yield different constructors that build chords from different information, each being provided sufficiently complete, but not redundant, information.

Another distinction to make is among the output formats provided by chord constructors. One group of constructors could yield the noteworthy strings that eventually end up on the tab staff and/or music staff in `tabr` output.
Another group of constructors could generate the chord format used for creating fretboard diagrams, which have a different syntax. Choice of output format could be an argument to a parent constructor, but there can also be separate groups of wrapper functions that default to each type of output.

In any case, this is mentioned here so that users are aware that there are development plans for chord construction that is tablature focused and helpful for guitar, and which does not look like the examples shown above. The more piano chord style convenience functions above will remain for programming purposes and whatever other conveniences they offer, but as chord construction in `tabr` receives further development, it is going to look very different, serve different purposes, and the currently available functions will look like an aside. There will likely be a few constructor functions that generate many guitar chords in various ways given different information. There will not be a large collection of functions named after specific guitar chords.
